# Техническое задание

На прошлых этапах мы получили 2 улучшения в системе:
- Новая архитектура базы данных,
- Динамическое обновление данных между базой данных и поисковым сервисом.  

Необходимо разработать сервис, который позволит создавать и редактировать сущности из подготовленной схемы. 

Основные этапы:
1. Создать структуру проекта Django.
2. Перенести в `models` схему, разработанную на ранних этапах.
3. Сравнить код, который был написан руками, c кодом, который генерирует Django автоматически,
4. Добавить механизмы работы с `models` для контент-менеджера.


## Основные сущности

Основные сущности, которые должны присутствовать в сервисе.

Список полей для каждой сущности является обязательным, но не ограничивается строго — возможно, в процессе вы почувствуете необходимость что-то добавить.

- Пользователь — электронная почта, логин, пароль, дата регистрации, система прав. 
- Фильм – заголовок, содержание, дата создания, режиссеры, актеры, сценаристы, жанры, ссылка на файл.
- Сериал - заголовок, содержание, даты создания, режиссеры, актеры, сценаристы, жанры, ссылка на файл.

- Актер — Имя, фамилия, его фильмы
- Режиссер — Имя, фамилия, его фильмы
- Сценарист — Имя, фамилия, его фильмы
- Жанр — Описание

>> Подсказка: 

- Надо создать модели в Django, которые бы описывали таблицы из схемы из части Проектирование Схемы БД - Авторское решение (то есть надо продолжать с авторским решением).

- Пользователь уже автоматически создается в Django админ, поэтому это уже будет решено как только будет работать админка Джанги.

- Фильм и Сериал это одна и таже таблица content.film_work. Там есть поле type, которое указывает фильм или сериал. В админ панели можно сделать фильтр по этому значению, как описано в теоретической части. Так как значений будет мало, то можно описать это поле например так: 
	
	# необходимые импорты

	class UpdatedCreatedMixin(models.Model):
		class Meta:
			abstract = True    # не будет создаваться таблица при миграции

		created_at = models.DateTimeField('дата создания', auto_created=True, auto_now_add=True)
		updated_at = models.DateTimeField('дата обновления', auto_now_add=True)


	class FilmWorkType(models.TextChoices):
	    MOVIE = 'movie', 'фильмы'
	    TV_SHOW = 'tv_show', 'шоу'


	class FilmWork(UpdatedCreatedMixin):
		...
		type = models.TextField('тип', choices=FilmWorkType.choices)
		...


- Актер, Режиссер, Сценарист это все таблица content.person. Связь person с фильмами(film_work) через таблицу content.person_film_work, где есть дополнительное поле role (можно описать также, как с типом фильма), которое указывает на роль в фильме (актер, режиссер, сценарист). Разделить в админ панели, например, можно через фильтры.

- Чтобы при миграции создавались нужные названия таблиц, надо в моделя добавлять class Meta, например:

	class PersonFilmWork(models.Model):
	    class Meta:
		    db_table = 'content"."person_film_work'   # можно вынести название схемы в settings в переменную
		                                              # f'{settings.CONTENT_SCHEMA}"."person_film_work'
		    # также можно указать другие полезные свойства
		    verbose_name = 'участинк'
		    verbose_name_plural = 'участники'
		    unique_together = ('film_work', 'person', 'role')
		    # и другие, есть в доках для джанги


## Требования к объему данных

Эти требования необходимы для проверки работы индексов в вашей базе. При тестировании приложения с небольшим количеством записей мы не сможем проверить, правильно ли выполнена часть задания с индексами.

- Пользователи > 1 000.
- Фильмы > 1 000 000.
- Сериалы > 200 000.
- Жанры > 10 000.
